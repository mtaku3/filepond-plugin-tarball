{"version":3,"file":"zipper.js","sources":["../src/types.ts","../src/zipper.ts","../src/utils.ts"],"sourcesContent":["import JSZip from 'jszip';\n\ndeclare global {\n  interface Window {\n    JSZip: JSZip;\n  }\n}\n\ninterface TargetFilter {\n  ADD_ITEMS: string;\n}\n\nexport type FilterKey = keyof TargetFilter;\n\nexport interface ItemType extends File {\n  _relativePath?: string;\n}\n\ntype FilterCallback = (items: ItemType[]) => Promise<ItemType[]>;\ntype AddFilterCallback = (key: FilterKey, callback: FilterCallback) => void;\n\nexport interface PluginOptions {\n  addFilter: AddFilterCallback;\n}\n\nexport interface Filter {\n  options: unknown;\n}\n\nexport type ZipperCallback = (items: Promise<ItemType>[]) => ItemType[];\n\nexport class Item extends File implements ItemType {\n  _relativePath?: string;\n}\n","import {Filter, PluginOptions, ZipperCallback} from './types';\nimport {generateZip} from './utils';\n\nconst Zipper = (callback?: ZipperCallback) => ({addFilter}: PluginOptions): Filter => {\n  addFilter('ADD_ITEMS', async (items) => {\n    const zips = generateZip(items);\n\n    const zipFiles = callback ? callback(zips) : await Promise.all(zips);\n\n    return items.filter((item) => !item._relativePath).concat(zipFiles || []);\n  });\n\n  return {options: {}};\n};\n\nexport default Zipper;\n","import JSZip from 'jszip';\nimport {Item, ItemType} from './types';\n\nexport const getDirectoryGroups = (items: ItemType[]): Record<string, ItemType[]> => {\n  const directories = {};\n\n  items\n    .filter((item) => item._relativePath)\n    .forEach((item) => {\n      const [, group] = item._relativePath.split('/');\n\n      if (!directories[group]) {\n        directories[group] = [];\n      }\n\n      directories[group].push(item);\n    });\n\n  return directories;\n};\n\nexport const generateZip = (items: ItemType[]): Promise<ItemType>[] => {\n  const directories = getDirectoryGroups(items);\n\n  return Object.keys(directories).map(async (name) => {\n    const zip = new JSZip();\n\n    directories[name].forEach((file) => {\n      zip.file(file._relativePath, file);\n    });\n\n    delete directories[name];\n\n    const file = await zip.generateAsync({type: 'blob'});\n\n    return new Item([file], `${name}.zip`);\n  });\n};\n"],"names":["Item","File","callback","addFilter","items","zipFiles","filter","item","_relativePath","concat","zips","directories","forEach","group","split","push","getDirectoryGroups","Object","keys","map","name","zip","JSZip","file","generateAsync","type","generateZip","Promise","all","options"],"mappings":"kFA+BaA,UAAaC,qBC5BVC,GAA8B,EAAEC,UAAAA,MAC9CA,EAAU,qBAAoBC,kBAGtBC,GAEN,OAAOD,EAAME,OAAQC,IAAUA,EAAKC,eAAeC,OAAOJ,GAAY,IAJtE,MAAMK,ECgBkBN,CAAAA,IAC1B,MAAMO,EAnB2BP,CAAAA,IACjC,MAAMO,EAAc,GAcpB,OAZAP,EACGE,OAAQC,GAASA,EAAKC,eACtBI,QAASL,IACR,OAASM,GAASN,EAAKC,cAAcM,MAAM,KAEtCH,EAAYE,KACfF,EAAYE,GAAS,IAGvBF,EAAYE,GAAOE,KAAKR,KAGrBI,GAIaK,CAAmBZ,GAEvC,OAAOa,OAAOC,KAAKP,GAAaQ,aAAWC,OACzC,MAAMC,EAAM,IAAIC,SAEhBX,EAAYS,GAAMR,QAASW,IACzBF,EAAIE,KAAKA,EAAKf,cAAee,YAGxBZ,EAAYS,mBAEAC,EAAIG,cAAc,CAACC,KAAM,wBAAtCF,GAEN,WAAWvB,EAAK,CAACuB,GAAUH,YAXtB,sCDnBQM,CAAYtB,0BAERF,IAAWA,EAASQ,oBAAciB,QAAQC,IAAIlB,aAHxD,qCAQF,CAACmB,QAAS"}