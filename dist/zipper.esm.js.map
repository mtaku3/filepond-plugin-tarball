{"version":3,"file":"zipper.esm.js","sources":["../src/types.ts","../src/utils.ts","../src/zipper.ts"],"sourcesContent":["interface TargetFilter {\n  ADD_ITEMS: string;\n}\n\nexport type FilterKey = keyof TargetFilter;\n\nexport interface ItemType extends File {\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  _relativePath?: string;\n}\n\ntype FilterCallback = (items: ItemType[]) => Promise<ItemType[]>;\ntype AddFilterCallback = (key: FilterKey, callback: FilterCallback) => void;\n\nexport interface PluginOptions {\n  addFilter: AddFilterCallback;\n}\n\nexport interface Filter {\n  options: unknown;\n}\n\nexport interface Metadata {\n  percent: number;\n  currentFile: string;\n}\n\nexport type OnUpdateCallback = (metadata: Metadata) => void;\n\nexport type GeneratorCallback = (onUpdate?: OnUpdateCallback) => Promise<ItemType>;\n\nexport type ZipperCallback = (generators: GeneratorCallback[]) => unknown;\n\nexport class Item extends File implements ItemType {\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  _relativePath?: string;\n}\n","import JSZip from 'jszip';\nimport {GeneratorCallback, Item, ItemType, OnUpdateCallback} from './types';\n\nconst directories = {};\n\nexport const getDirectoryGroups = (items: ItemType[]): Record<string, ItemType[]> => {\n  items\n    .filter((item) => item._relativePath)\n    .forEach((item) => {\n      const [, group] = item._relativePath.split('/');\n\n      if (!directories[group]) {\n        directories[group] = [];\n      }\n\n      directories[group].push(item);\n    });\n\n  return directories;\n};\n\nexport const generateZip = (items: ItemType[]): GeneratorCallback[] => {\n  getDirectoryGroups(items);\n\n  return Object.keys(directories).map((name) => {\n    const zip = new JSZip();\n\n    directories[name].forEach((file) => {\n      zip.file(file._relativePath, file);\n    });\n\n    // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n    delete directories[name];\n\n    return async (onUpdate?: OnUpdateCallback): Promise<ItemType> => {\n      const file = await zip.generateAsync({type: 'blob'}, onUpdate);\n\n      return new Item([file], `${name}.zip`);\n    };\n  });\n};\n","import {Filter, PluginOptions, ZipperCallback} from './types';\nimport {generateZip} from './utils';\n\nconst FilepondZipper =\n  (callback?: ZipperCallback) =>\n  ({addFilter}: PluginOptions): Filter => {\n    addFilter('ADD_ITEMS', async (items) => {\n      const generators = generateZip(items);\n      const plainFiles = items.filter((item) => !item._relativePath);\n\n      if (callback) {\n        callback(generators);\n\n        return plainFiles;\n      }\n\n      const zipFiles = await Promise.all(generators.map((generate) => generate()));\n\n      return plainFiles.concat(zipFiles);\n    });\n\n    return {options: {}};\n  };\n\nexport default FilepondZipper;\n"],"names":["Item","File","_relativePath","directories","FilepondZipper","callback","addFilter","items","filter","item","forEach","group","split","push","getDirectoryGroups","Object","keys","map","name","zip","JSZip","file","onUpdate","Promise","resolve","generateAsync","type","then","e","reject","generateZip","plainFiles","generators","all","generate","zipFiles","concat","options"],"mappings":"qBAiCaA,MAAAA,UAAaC,wCAExBC,mBAF4B,GC9B9B,MAAMC,EAAc,GCAAC,EACjBC,GACD,EAAEC,UAAAA,MACAA,EAAU,YAAD,SAAqBC,GAArB,IACP,QDcsBA,CAAAA,IAhBOA,CAAAA,IACjCA,EACGC,OAAQC,GAASA,EAAKP,eACtBQ,QAASD,IACR,MAAM,CAAGE,GAASF,EAAKP,cAAcU,MAAM,KAEtCT,EAAYQ,KACfR,EAAYQ,GAAS,IAGvBR,EAAYQ,GAAOE,KAAKJ,MAO5BK,CAAmBP,GAENQ,OAACC,KAAKb,GAAac,IAAKC,IACnC,MAAMC,EAAM,IAAIC,EAShB,OAPAjB,EAAYe,GAAMR,QAASW,IACzBF,EAAIE,KAAKA,EAAKnB,cAAemB,cAIZH,GAEnB,SAAcI,GAAkD,IAAA,OAAAC,QAAAC,QAC3CL,EAAIM,cAAc,CAACC,KAAM,QAASJ,IADSK,KAAA,SACxDN,GAEN,WAAOrB,EAAS,CAACqB,GAAU,GAAAH,WAH7B,MAKDU,GAAA,OAAAL,QAAAM,OAAAD,QChCsBE,CAAYvB,GACzBwB,EAAaxB,EAAMC,OAAQC,IAAUA,EAAKP,eAEhD,OAAIG,GACFA,EAAS2B,mBAEFD,IAGcR,QAAAA,QAAAA,QAAQU,IAAID,EAAWf,IAAKiB,GAAaA,qBAA1DC,GAEN,OAAiBJ,EAACK,OAAOD,KAZlB,qCAeF,CAACE,QAAS"}