{"version":3,"file":"zipper.umd.js","sources":["../src/types.ts","../src/main.ts","../src/utils.ts"],"sourcesContent":["interface TargetFilter {\n  FILTER_DROPPED_ITEMS: string;\n}\n\nexport type FilterKey = keyof TargetFilter;\n\nexport interface ItemType extends File {\n  _relativePath?: string;\n}\n\ntype FilterCallback = (items: ItemType[]) => Promise<ItemType[]>;\ntype AddFilterCallback = (key: FilterKey, callback: FilterCallback) => void;\n\nexport interface PluginOptions {\n  addFilter: AddFilterCallback;\n}\n\nexport interface Filter {\n  options: unknown;\n}\n\nexport type ZipperCallback = (items: Promise<ItemType[]>) => ItemType[];\n\nexport class Item extends File implements ItemType {\n  _relativePath?: string;\n}\n","import { Filter, PluginOptions, ZipperCallback } from \"./types\";\nimport {generateZip} from \"./utils\";\n\nconst Zipper = (callback?: ZipperCallback) => ({\n  addFilter,\n}: PluginOptions): Filter => {\n  addFilter(\"FILTER_DROPPED_ITEMS\", async (items) => {\n    const make = () => generateZip(items);\n\n    const zipFiles = callback\n      ? callback(make())\n      : await make();\n\n    return items.filter((item) => !item._relativePath).concat(zipFiles || []);\n  });\n\n  return { options: {} };\n};\n\nexport default Zipper;\n","import Zip from \"jszip\";\nimport { Item, ItemType } from \"./types\";\n\nexport const getDirectoryGroups = (items: ItemType[]): Map<string, ItemType[]> => {\n  const directories = new Map();\n\n  items\n    .filter((item) => item._relativePath)\n    .forEach((item) => {\n      const [, group] = item._relativePath.split(\"/\");\n      if (!directories.has(group)) {\n        directories.set(group, []);\n      }\n\n      directories.get(group).push(item);\n    });\n\n  return directories;\n};\n\nexport const generateZip = (items: ItemType[]): Promise<ItemType[]> => {\n  const directories = getDirectoryGroups(items);\n  const generators = Array.from(directories.keys()).map(async (name) => {\n    const zip = new Zip();\n    directories.get(name).forEach((file) => {\n      zip.file(file._relativePath, file);\n    });\n\n    directories.delete(name);\n\n    const file = await zip.generateAsync({ type: \"blob\" });\n\n    return new Item([file], `${name}.zip`);\n  });\n\n  return Promise.all(generators);\n};\n"],"names":["Item","File","callback","addFilter","items","zipFiles","filter","item","_relativePath","concat","make","directories","Map","forEach","group","split","has","set","get","push","getDirectoryGroups","generators","Array","from","keys","map","name","zip","Zip","file","delete","generateAsync","type","Promise","all","generateZip","options"],"mappings":"wSAuBaA,UAAaC,aCpBVC,GAA8B,EAC5CC,UAAAA,MAEAA,EAAU,gCAA+BC,kBAGjCC,GAIN,OAAOD,EAAME,OAAQC,IAAUA,EAAKC,eAAeC,OAAOJ,GAAY,IANtE,MAAMK,EAAO,ICaWN,CAAAA,IAC1B,MAAMO,EAlB2BP,CAAAA,IACjC,MAAMO,EAAc,IAAIC,IAaxB,OAXAR,EACGE,OAAQC,GAASA,EAAKC,eACtBK,QAASN,IACR,OAASO,GAASP,EAAKC,cAAcO,MAAM,KACtCJ,EAAYK,IAAIF,IACnBH,EAAYM,IAAIH,EAAO,IAGzBH,EAAYO,IAAIJ,GAAOK,KAAKZ,KAGzBI,GAIaS,CAAmBhB,GACjCiB,EAAaC,MAAMC,KAAKZ,EAAYa,QAAQC,aAAWC,OAC3D,MAAMC,EAAM,IAAIC,SAChBjB,EAAYO,IAAIQ,GAAMb,QAASgB,IAC7BF,EAAIE,KAAKA,EAAKrB,cAAeqB,KAG/BlB,EAAYmB,OAAOJ,mBAEAC,EAAII,cAAc,CAAEC,KAAM,wBAAvCH,GAEN,WAAW7B,EAAK,CAAC6B,GAAUH,YAVV,qCAanB,OAAOO,QAAQC,IAAIb,ID5BEc,CAAY/B,0BAEdF,IACbA,EAASQ,sBACHA,cALH,qCAUF,CAAE0B,QAAS"}